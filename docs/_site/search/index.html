<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="generator" content="Jekyll v3.3.0">

		<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700">
		<link rel="stylesheet" href="/css/main.css">
		<link rel="apple-touch-icon" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" href="/touch-icon.png" sizes="192x192">
		<link rel="icon" type="image/png" href="/images/favicon.png">

		<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blender" />
		<!-- Begin Jekyll SEO tag v2.1.0 -->
<title>Search - Blender</title>
<meta property="og:title" content="Search" />
<meta name="description" content="A modularity first language construction workbench" />
<meta property="og:description" content="A modularity first language construction workbench" />
<link rel="canonical" href="http://localhost:4000/search/" />
<meta property="og:url" content="http://localhost:4000/search/" />
<meta property="og:site_name" content="Blender" />
<script type="application/ld+json">
{"@context": "http://schema.org",
"@type": "WebPage",
"headline": "Search",
"description": "A modularity first language construction workbench",
"publisher": {"@type": "Organization",
"logo": {"@type": "ImageObject",
"url": "http://localhost:4000/favicon.png"}},
"url": "http://localhost:4000/search/"}</script>
<!-- End Jekyll SEO tag -->


		
	</head>

	<body>
		<header>
			<h1>
				<a href="/"><img src="/images/favicon.png" width="40" height="40" alt="Blender logo"></a>
				Blender
				<button type="button" class="open-nav" id="open-nav"></button>
			</h1>

			<form action="/search/" method="get">
				<input type="text" name="q" id="search-input" placeholder="Search" autofocus>
				<input type="submit" value="Search" style="display: none;">
			</form>

			<nav class="full-navigation">
				<ul>
					<li class="nav-item top-level ">
						
						<a href="/">Blender</a>
					</li>
				</ul>

				<ul>
					
					
						<li class="nav-item top-level current">
							<a href="">Core</a>
							<ul>
								
								
									
								
									
								
									
								
									
								
									
										<li class="nav-item "><a href="/core/what-is-a-language/">What is a language?</a></li>
									
								
									
								
									
								
									
								
									
										<li class="nav-item "><a href="/core/delta/">Delta</a></li>
									
								
									
								
									
										<li class="nav-item "><a href="/core/node/">Node</a></li>
									
								
									
								
									
										<li class="nav-item "><a href="/core/effective-blender/">Effective Blender</a></li>
									
								
									
										<li class="nav-item "><a href="/core/sandbox/">Sandbox</a></li>
									
								
							</ul>
						</li>
					
						<li class="nav-item top-level current">
							<a href="/deltas/built-in-languages/">Grammar</a>
							<ul>
								
								
									
								
									
								
									
										<li class="nav-item "><a href="/grammar/bigrammar/">BiGrammar</a></li>
									
								
									
								
									
								
									
								
									
								
									
										<li class="nav-item "><a href="/grammar/unified-parsing-and-printing/">Unified Parsing & Printing</a></li>
									
								
									
								
									
										<li class="nav-item "><a href="/grammar/modularity/">Modularity</a></li>
									
								
									
								
									
										<li class="nav-item "><a href="/grammar/trivia/">Trivia</a></li>
									
								
									
								
									
								
							</ul>
						</li>
					
						<li class="nav-item top-level current">
							<a href="/deltas/built-in-languages/">Java</a>
							<ul>
								
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
							</ul>
						</li>
					
						<li class="nav-item top-level current">
							<a href="/deltas/built-in-languages/">Practical</a>
							<ul>
								
								
									
								
									
										<li class="nav-item "><a href="/practical/build/">Build instructions</a></li>
									
								
									
								
									
								
									
								
									
										<li class="nav-item "><a href="/practical/contributions/">Contributions</a></li>
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
							</ul>
						</li>
					
						<li class="nav-item top-level current">
							<a href="/deltas/built-in-languages/">Discussion</a>
							<ul>
								
								
									
								
									
								
									
								
									
										<li class="nav-item "><a href="/discussion/related-projects/">Related projects</a></li>
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
							</ul>
						</li>
					
				</ul>
			</nav>
		</header>

		<section class="main">
			<div class="page-header">
				<h2></h2>
				<h3>Search</h3>
			</div>
			<article class="content">
				<p><span id="search-process">Loading</span> results <span id="search-query-container" style="display: none;">for "<strong id="search-query"></strong>"</span></p>
<ul id="search-results"></ul>

<script>
	window.data = {
		
			
				
					
					

					"core-delta": {
						"id": "core-delta",
						"title": "Delta",
						"category": "",
						"url": " /core/delta/",
						"content": "In Blender, language transformations are packaged as re-usable units. Such a unit is called a Delta. Commonly, a delta applies a small change to a language, such as adding or removing a language feature, or adding an optimization. Languages are defined by composing many Delta’s. By keeping Delta’s simple and language agnostic, they can be reused for different languages. A similar approach is described in the paper A Nanopass Framework for Compiler Education.\n\nDelta’s can, and commonly do, depend on other Delta’s. For example, WhileContinueDelta, that allows using the continue statement in a Java while loop, depends on WhileDelta, that defines a Java while loop, which depends on StatementSkeleton that defines the concept of a statement, etc.\n\n\n  Discuss compilation\nDiscuss language class\n\n\nAn overview of Delta’s and their dependencies can be seen in the architecture panel, which is part of the Blender desktop application.\n\n\n  Add link"
					}

					
				
			
		
			
				
					,
					

					"core-effective-blender": {
						"id": "core-effective-blender",
						"title": "Effective Blender",
						"category": "",
						"url": " /core/effective-blender/",
						"content": "This article is under construction.\n\n\nTo use Blender effectively requires writing some boilerplate. For each type of Node, we need to define one NodeClass object, and a NodeField object for each field. Then, to make using the accessing fields of the new Node type easier, we need a subclass of NodeWrapper. Scala macro’s might help us here in the future, but currently they are not mature enough. For now we’ve written a generator for the boilerplate. Here follows an example of the generator in action:\n\nGiven the following input:\nscala\nobject ClassFileDelta {\n  val input = new NodeClassDefinition(\"ClassFile\", \n    \"classInfoIndex\" -&gt; \"Int\",\n    \"interfaces\" -&gt; \"Seq[Int]\",\n    \"methods\" -&gt; wrapSeq(\"Seq[MethodInfo]\"),\n    \"attributes\" -&gt; \"Seq[Node]\"\n  )\n\nIt outputs:\n```scala\nobject ClassFileDelta {\n  val input = new NodeClassDefinition(“ClassFile”, \n    “classInfoIndex” -&gt; “Int”,\n    “interfaces” -&gt; “Seq[Int]”,\n    “methods” -&gt; wrapSeq(“Seq[MethodInfo]”),\n    “attributes” -&gt; “Seq[Node]”\n  )\n\n//region Generated Node boilerplate\n  object Clazz extends NodeClass\n  object Interfaces extends NodeField\n  object Methods extends NodeField\n  object Attributes extends NodeField\n\nimplicit class ClassFileT &lt;: NodeLike extends NodeWrapper {\n    assert(node.clazz == Clazz)\n\ndef interfaces: Seq[Int] = node(Interfaces).asInstanceOf[Seq[Int]]\ndef interfaces_(value: Seq[Int]): Unit = node(Interfaces) = value\n\ndef methods: Seq[MethodInfo[T]] = NodeWrapper.wrapSeq(node(Methods).asInstanceOf[Seq[T]])\ndef methods_(value: Seq[MethodInfo[T]]): Unit = node(Methods) = NodeWrapper.unwrapSeq(value)\n\ndef attributes: Seq[T] = node(Attributes).asInstanceOf[Seq[T]]\ndef attributes_(value: Seq[T]): Unit = node(Attributes) = value   }     //endregion } ```\n\n\n\nThe generic type argument for the wrappers allows it to wrap around both Node and Path types. Wrapped fields can either wrap around regular types, other wrappers, or sequences of other wrappers."
					}

					
				
			
		
			
				
					,
					

					"core-node": {
						"id": "core-node",
						"title": "Node",
						"category": "",
						"url": " /core/node/",
						"content": "Node is the type used to define abstract syntax tree nodes in Blender."
					}

					
				
			
		
			
				
					,
					

					"core-sandbox": {
						"id": "core-sandbox",
						"title": "Sandbox",
						"category": "",
						"url": " /core/sandbox/",
						"content": "Blender can be run as a desktop application, which provides a sandbox for constructing languages from the Delta’s defined beforehand.\n\nOnce you’ve composed a language from a set of Delta’s you can play around with it in the language cockpit. Here you can write programs in the language supported by language specific tooling, compile those programs and pretty print the target language, run those programs, determine which compilation phases the language’s compiler has, and inspect the language’s in- and output grammar.\n\n\n  Add screenshot\n\n\n\n  Show and mention architecture panel\n\n\nTo see Blender’s sandbox in action, watch our introduction video."
					}

					
				
			
		
			
				
					,
					

					"core-what-is-a-language": {
						"id": "core-what-is-a-language",
						"title": "What is a language?",
						"category": "",
						"url": " /core/what-is-a-language/",
						"content": "This article is under construction\n\n\nHere are some examples of language parts which can be defined using metalanguages:\n\n\n  Syntax: parsers, printers, code completion.\n  Compile-time semantics: name binding, type checking, intellisense\n  Run-time semantics: compilers, interpreters"
					}

					
				
			
		
			
				
					,
					

					"deltas-built-in-languages": {
						"id": "deltas-built-in-languages",
						"title": "Built-in languages",
						"category": "",
						"url": " /deltas/built-in-languages/",
						"content": ""
					}

					
				
			
		
			
				
					,
					

					"deltas-inline-constant-pool": {
						"id": "deltas-inline-constant-pool",
						"title": "Inline constant pool",
						"category": "",
						"url": " /deltas/inline-constant-pool/",
						"content": ""
					}

					
				
			
		
			
				
					,
					

					"discussion-related-projects": {
						"id": "discussion-related-projects",
						"title": "Related projects",
						"category": "",
						"url": " /discussion/related-projects/",
						"content": "Blender is written in Scala, which serves as a host language for its embedded metalanguages. Some workbenches like Rascal define stand-alone metalanguages with general purpose programming facilities. This provides a smooth experience when using the language, but leaves you without the ecosystem of a popular language. Other workbenches like Spoofax and MPS define metalanguages optimized for usability, leaving out generic programming facilities. While these languages are user-friendly, they are not suitable for being transformed."
					}

					
				
			
		
			
				
					,
					

					"grammar-bigrammar": {
						"id": "grammar-bigrammar",
						"title": "BiGrammar",
						"category": "",
						"url": " /grammar/bigrammar/",
						"content": "Blender’s metalanguage for everything syntax related is called BiGrammar, which defines both a parser and a printer at the same time. The techniques underlying this are similar to those described in the paper Invertible Syntax Descriptions: Unifying Parsing and Pretty Printing.\n\nA BiGrammar may be defined in a left recursive fashion, which can be contributed to the use of packrat parsing with support for left-recursion. The work underlying this is described in the papers Packrat Parsing: Simple, Powerful, Lazy, Linear Time and Packrat Parsers Can Support Left Recursion.\n\nNext\nRead how BiGrammar implements unified parsing and printing"
					}

					
				
			
		
			
				
					,
					

					"grammar-modularity": {
						"id": "grammar-modularity",
						"title": "Modularity",
						"category": "",
						"url": " /grammar/modularity/",
						"content": "The #1 focus of Blender is to enable modular language design. This page explains how BiGrammar supports that goal.\n\nIn Unified parsing and printing we introduced the as operator which binds a grammar to a field in the AST. This method of mapping a grammar to an AST, where the binding to a field is separate from the binding to a node, is a bit peculiar. It is common when using parser combinators, to first parse tuples of values using the sequence combinator, ~ in our case, and then apply a function to map those tuples to an AST node, for example:\nscala\n(expression ~&lt; \"|\" ~ expression).map(\n      { case ~(left, right) =&gt; new Or(left, right) }, //Constructor\n      (or: Or) =&gt; Some(~(or.left, or.right))) //Destructor\n\n\nNow suppose we want a grammar that has both | and ||, to indicate whether to evaluate the arguments lazily or strict. If we would write this grammar from scratch, we could write:\n\nval strict = (\"|\" ~&gt; value(false) | value(true))\nval inner = expression ~&lt; \"|\" ~ strict ~ expression\ninner.map({ case ~(~(left, strict: Boolean), right) =&gt; Or(left, right, strict) },\n          (or: Or) =&gt; Some(new ~(new ~(or.left, or.strict), or.right)))\n\n\nHowever, if we want to get this second grammar by transforming the first, then things will get messy. We’ll need to change code in multiple locations, both in the inner grammar, but also in both functions passed to map.\n\nNow let’s use the as and asNode style to bind our grammar to the AST. The initial grammar is\nscala\nval grammar = expression.as(Left) ~ \"|\" ~ expression.as(Right) asNode Or\n\nwhich we can transform using\nscala\nval strict = (\"|\" ~&gt; value(false) | value(true)).as(Strict)\ngrammar.findAs(Right).replace(original =&gt; strict ~ original)\n\nto get the grammar with lazyness\nscala\nval lazyGrammar = expression.as(Left) ~&lt; \"|\" ~ strict ~ expression.as(Right) asNode Or\n\nWe can transform back to the initial grammar using\nscala\ngrammars.findAs(Strict).removeFromSequence()\n\n\nHere are the explanations for some of the methods used:\n- findAs traverses a BiGrammar and returns a GrammarReference, which is a zipper for grammars. It defines a path through the grammar, starting at a root grammar. It is a convenient type for traversing and updating a grammar.\n- replace changes the reference to this grammar to a new grammar passed to replace.\n- removeFromSequence assumes that the grammar is to the left or right of a sequence operator such as ~, and replaces that sequence operator with the operator that is not the current grammar.\n\nFor example: (a ~ b).findAs(a).removeFromSequence() results in b"
					}

					
				
			
		
			
				
					,
					

					"grammar-trivia": {
						"id": "grammar-trivia",
						"title": "Trivia",
						"category": "",
						"url": " /grammar/trivia/",
						"content": "In Modularity we showed some of the features of BiGrammar that enable modularity. In this article, we’ll demonstrate the extent of BiGrammar’s modularity by showing off delta’s that change the entire grammar of a language.\n\n\n  Introduce concept of a language pipeline to replace the usage of ‘target’\n\n\nTo demonstrate these delta’s, we need a target for them to transform. We choose a simple refactoring that reorders the members of a Java class, so that static fields are placed before instance fields. The problem is that this refactoring is incomplete: it only works on Java programs without comments. A series of three delta’s will enable the refactoring to accept Java block comments in the input program, and to output them in the refactored program, in an way that matches with how programmers use comments.\n\nOur input program for this case is the following:\n\nclass Example {\n    int first;\n    /* second is used for foo */\n    public static /* bar */ int second;\n}\n\n\n\nIf we apply reorder members on this program, we get the following exception:\n\n[5.5] failure: `}' expected but `/' found\n\n    /* second is for XYZ */\n    ^\n\n\n\nWe can allow comment parsing using a very simple delta, but to understand how that works first we need to see how whitespace parsing is defined in our example Java language. By default, languages in Blender define a grammar called TriviaGrammar that parses whitespace. Given a Language, we can use import language.grammars._ to get a set of language specific parser combinators. These combinators, such as ~, will use the language’s TriviaGrammar as a separator when placing other grammars in sequence. Here is an example that defines part of the Java grammar used for our earlier program:\n\n  override def transformGrammars(language: Language): Unit = {\n    import language.grammars._\n\n    //Create an empty named grammar, that we can modify in another delta.\n    val classMember = create(ClassMemberGrammar) \n\n    val nameGrammar = \"class\" ~~&gt; identifier.as(ClassName)\n    val membersGrammar = classMember.manyVertical.indent(4).as(Members)\n    val classGrammar = packageGrammar % importsGrammar % \n      nameGrammar ~&lt; \"{\" % membersGrammar %&lt; \"}\" asLabelledNode Clazz\n\n    //BodyGrammar is the file's top level grammar\n    find(BodyGrammar).inner = classGrammar \n  }\n\n\n\nNow that we know about TriviaGrammar, we can understand how the following Delta adds comment parsing to the language:\n\nobject JavaStyleCommentsDelta extends DeltaWithGrammar {\n  override def transformGrammars(grammars: LanguageGrammars, state: Language) = {\n    val commentGrammar = RegexGrammar(\"\"\"(?s)/\\*.*?\\*/\"\"\".r)\n    grammars.find(TriviaGrammar).addOption(getCommentGrammar)\n  }\n}\n\n\n\nIf we add this delta to our refactoring, and then apply it, we get the following output program:\n\nclass Example {\n    static int second;\n    int first;\n}\n\n\n\nThe reordering has completed but all the comments are gone! To retain our comments in the output, we’ll add another delta, StoreTriviaDelta, that causes the results from TriviaGrammar to be stored in the AST. With this delta added to our refactoring, we get the following output:\n\nclass Example {\n    public static /* bar */ int second;\n    /* second is used for foo */\n    int first;\n}\n\n\n\nThis is quite good! All the comments are still there in the output, and the /* bar */ comment inside the second field has moved with the field. However, one last thing still irks us. The comment /* second is used for foo */ is in the same position as before, in front of the field first, even though it is meant to clarify the meaning of the field second.\n\nThe reason for this is that the comment, because it is located between two fields, is stored not in one of the field nodes, but in the class node. We can add one last delta, TriviaInsideNode, that will improve this behavior, so that trivia located right in front of a node, will be stored inside that node, instead of the parent node. The resulting output is now:\n\nclass Example {\n    /* second is used for foo */\n    public static /* bar */ int second;\n    int first;\n}\n\n\n\nPerfect!\n\nThe refactoring used as a target in this article is a minimal example, but since the three delta’s we used are all language agnostic, we can use them in any context, for example when transforming from Java to C#."
					}

					
				
			
		
			
				
					,
					

					"grammar-unified-parsing-and-printing": {
						"id": "grammar-unified-parsing-and-printing",
						"title": "Unified Parsing &amp; Printing",
						"category": "",
						"url": " /grammar/unified-parsing-and-printing/",
						"content": "BiGrammar is a DSL that allows the user to define both a parser and a pretty printer at the same time. Operators and methods in BiGrammar will often have an effect on both the parser and the printer, both can sometimes influence only one of both.\n\nExample\nHere follows an example of a small piece of grammar defined using BiGrammar:\n\n\"while\" ~ expression.inParenthesis.as(Condition) ~~ \"{\" %\n        statement.manyVertical.indent(2).as(Body) %\n        \"}\" asNode While\n\n\nThe grammars for expression and statement have been left out for brevity.\n\nThe operators have the following meaning:\n- ~ is horizontal separation.\n- ~~ is the same as ~ when parsing, but when printing adds a space between the left and right grammar. \n- % is vertical separation.\n- as binds the grammar to a field in the AST\n- asNode binds the grammar to a node in the AST\n- indent indents the grammar on which it is applied, but only when printing.\n\nWith the defined BiGrammar, we can parse the following program (ugly formatting is intentional)\njava\nwhile (i){\n  i--; x += 2;\n}\n\n\nyielding this AST\n\nClass: While\nCondition: \n  Class: Variable\n  Name: i\nBody:\n  - Class: Decrement\n    Target: i\n  - Class: PlusEquals\n    Target: x\n    Value: \n      Class: Constant\n      Value: 2  \n\n\nwhich can be pretty printed to\nJava\nwhile(i) {\n  i--;\n  x += 2;\n}\n\n\nChoice, ignore and value\nHere is another example grammar:\nscala\n\"yes\" ~&gt; value(true) | \"no\" ~&gt; value(false)\n\n- | is the choice operator. If the left grammar fails to parse/print, then the right grammar is used.\n- The &lt; and &gt; symbols can be added to the end of existing operators to create a variation, &lt; means ignore the result of the grammar to the right, so a ~&gt; b means a left of b, but ignore the result of a when parsing.\n- value has no effect on the syntax, it will produce a value when parsing and consume one while printing.\n\nRegex and map\nHere is another example:\nscala\nnew RegexGrammar(\"\"\"-?\\d+\"\"\".r).map(\n  afterParsing = (s: String) =&gt; Integer.parseInt(s), \n  beforePrinting =  (i: Int) =&gt; Some(i.toString)\n)\n\n- RegexGrammar turns a regular expression into a grammar\n- map transforms the grammar’s value using a bidirectional mapping. The argument beforePrinting returns an Option to allow printing to fail if the passed value does not belong to the grammar.\n\nNext\nRead how BiGrammar supports modular language design"
					}

					
				
			
		
			
				
					,
					

					"practical-build": {
						"id": "practical-build",
						"title": "Build instructions",
						"category": "",
						"url": " /practical/build/",
						"content": "Building Blender is as simple:\n\n\n  Grab the source from GitHub\n  Install sbt\n  Call ‘sbt run’ in the project root to build Blender and start the sandbox desktop application."
					}

					
				
			
		
			
				
					,
					

					"practical-contributions": {
						"id": "practical-contributions",
						"title": "Contributions",
						"category": "",
						"url": " /practical/contributions/",
						"content": "There’s an infinite amount of work to be done for Blender, so contributions are very welcome. There are many different topics to work on, some suitable for a Bachelor’s or Master’s thesis.\n\nSome examples of cool features:\n\n\n  Parser combinators that allow defining indentation sensitive grammars, such as those of Python and Haskell.\n  A DSL for static semantics, such as name binding and type checking. See the paper A constraint language for static semantic analysis based on scope graphs for inspiration\n  Error correcting parsing\n  Generating syntactic code completion from a grammar, as in the paper Principled syntactic code completion using placeholders\n  Incremental compilation: incremental parsing, incremental type checking, etc.\n  Add a new language front-end or back-end.\n\n\nHow to contribute\n\n  Reach out to rgv.willems@gmail.com, so he can help you out where the documentation is lacking.\n  Look through the open issues to see if you find something interesting\n  Enjoy the work ;-)\n  Once you’re done, submit a pull request and make sure the build server approves it."
					}

					
				
			
		
	};
</script>
<script src="/scripts/lunr.min.js"></script>
<script src="/scripts/search.js"></script>

			</article>
		</section>

		<script>
			document.getElementById("open-nav").addEventListener("click", function () {
				document.body.classList.toggle("nav-open");
			});
		</script>
	</body>
</html>
